Часть 1 (Теория)
===

1. Написать что выводит данный код. Предложите 2 варианта модификации кода, чтобы ответ был следующим: Bad: 10, Bad: 12, Good: 15, Good: 21

```
const arr = [10, 12, 15, 21];

  for (var i = 0; i < arr.length; i++) {
    setTimeout(function() {
      console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`);
    }, 3000);
  }
```

## Мой ответ

Через 3 секунды в консоли появится 4 сообщения `Bad: undefined`. 
Дело в области видимости. Переменные, объявленные через var, имеют глобальную область видимости. 
В исходном коде по завершении цикла i будет иметь значение 4, а элемента с таким индексом в массиве arr не существует.
Поэтому получаем условие underfined > 13 ? вернёт false и отобразится ветка `Bad: ${arr[i]}`.

* Первый вариант "исправления" кода:
```
for (let i = 0; i < arr.length; i++) {
      setTimeout(function() {
        console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`);
      }, 3000);
  }
```
Если объявить переменную i через let, то область видимости будет блочная,
поэтому в каждой итерации она будет пересоздаваться заново. И в замыкание
попадёт то значение i, которое было в момент вызова setTimeout.

* Второй вариант "исправления" кода:
```
for (var i = 0; i < arr.length; i++) {
    setTimeout(function(i) {
      console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`);
    }, 3000, i);
  }
```
Здесь i передано в качестве аргумента сначала в setTimeout, а потом 
во внутреннюю функцию. Что также через замыкание фиксирует значение i
в момент вызова функций.
